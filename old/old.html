  <!--<script src="js/app.js" defer></script>-->
  <!--<script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.4.0/p5.min.js"></script>-->


  <!-- <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script> -->

  <script type="text/javascript" id="MathJax-script" async
          src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script>

  <script>
    MathJax = {
      loader: {
        load: [
          'input/tex',
          'output/chtml'
        ]
      },
      tex: {
        inlineMath: [['$', '$']],
      }
    };
  </script>


      <h1>Mathematical Background</h1>

      <h2>Deferred Correction</h2>
      <p>
          Deferred Correction is a method to obtain higher-order solutions for an initial value problem by iterating and refining an initial approximation.
      </p>

      <p>
          Given an ODE initial value problem in the Picard formulation with
          $U_0 \in R^{n}$ being the initial value at $t = 0$, and $f(t, u(t)): R \times R^{n} \rightarrow R^{n}$ being the derivative of $u$ at $t$:
      </p>

      $$
      u(t) = U_0 + \int_{0}^{t} f(s, u(s)) \,ds
      $$

      <p>
          An approximation $\tilde{u}_{0}(t_i)$ of $u(t_i)$ can be computed at timesteps $t_{0}, \ldots t_{N}$.
      </p>

      <p>
          Using an interpolation scheme, we can find a continous approximation $\tilde{u}_{0}$ for all $t \in \left[ 0; T\right]$, e.g.
          using a Lagrangian interpolation polynomial.
      </p>

      <p>
          This allows us to define the error function:
      </p>

      $$
      e(t) = u(t) - \tilde{u}_{0}(t)
      $$

      <!-- <p>
           and the residual function:
           </p>

           $$
           r(t) = \left( U_0 + \int_{0}^{t} f(s, \tilde{u}_{0}(s)) \,ds \right) - \tilde{u}_{0}(t)
           $$

           <p>
           The residual function can be easily computed, while computing the error is equivalent to solving the IVP (as one can be easily computed from the other).
           </p>
      -->
      <p>
          The underlying idea of Deferred Correction is to express the error function as a time-dependent ODE, whose approximation can improve our initial approximation of $u(t)$.
          By applying the derivate on both sides of the error equation, we get:
      </p>

      $$
      \begin{align}
      \frac{d}{dt}{e(t)} &= \frac{d}{dt}u(t) - \frac{d}{dt}\tilde{u}_{0}(t) \\
                         &= f(t,u(t)) - \frac{d}{dt}\tilde{u}_{0}(t) \\
                         &= f(t,e(t) + \tilde{u}_{0}(t)) - \frac{d}{dt}\tilde{u}_{0}(t) \\
      \end{align}
      $$

      <p>
          As we are given the exact solution $u(0) = U_0$ at $t=0$, we have $e(0) = 0$.
          This provides as with an initial value and we have found a new IVP that we can solve using a time stepping method.
          Iteratively, we can improve our initial guess of $u(t)$ to achieve higher-order solutions $\tilde{u}_{j}(t)$.
      </p>


      <!-- TODO: hier noch mehr, vlt interaktives plot dings -->

      <p>
          The Deferred Correction method has multiple shortcomings, namely:
          <ul>
              <li>Computing the derivative for the error ODE can lead to numerical instabilities.</li>
              <li>Interpolation on equvidistant grid points may lead to the Runge-effect.</li>
          </ul>
      </p>


      <h2>Spectral Deferred Correction</h2>

      <p>
          Spectral Deferred Correction tries to solve the shortcomings of classical Deferred Correction by:
          <ul>
              <li>Reformulating the error equation using the residual to replace the derivative with integrals.</li>
              <li>Using spectral integration to compute these integrals.</li>
              <li>Replacing equvidistant time stepping points with quadrature nodes to improve the method's robustness.</li>
          </ul>
      </p>


      <h2>Full Approximation Scheme</h2>

      <h2>Parallel-in-Time Methods and Parareal</h2>

      <p>
          Traditionally, solvers use spatial paralellism to speed up the computation.
          However, this type of paralellism does not scale infinitely and at some points, the cost of parallelization may become to high.
      </p>

      <p>
          To bypass this problem, there has been ongoing efforts to exploit parallelization in the time domain.
          See <a href="https://parallel-in-time.org/">here</a> for an overview over existing methods and publications.
      </p>


      <h2>PFASST</h2>

      <p>
          The <i>Parallel Full Approximation Scheme in Space and Time</i> (<b>PFASST</b>) is a <i>Parallel-in-Time</i> method for solving <i>Partial Differential Equations</i> (<b>PDE</b>s).
      </p>

      <p>
          It was first introduced by Matthew Emmet and Michael L. Minion in their 2012 paper <a href="https://msp.org/camcos/2012/7-1/p04.xhtml"><cite>Toward an efficient parallel in time method for partial differential equations</cite></a>.
          <i>PFASST</i> combines aspects of the Parareal method with Spectral Deferred Correction and the Full-Approximation Scheme.
      </p>

    </div>
  </div>





  <!-- <div id="seqcontainer" class="animcontainer" style="display:none;"> -->
  <!--     <div style="display:flex"> -->
  <!--         <div class="space"> -->
  <!--             Space<br/>Dimension -->
  <!--         </div> -->
  <!--         <div> -->
  <!--             <div class="time"> -->
  <!--                 Time Dimension -->
  <!--             </div> -->
  <!--             <div id="seqcanvas"></div> -->
  <!--             <div class="playpause"> -->
  <!--                 <button id="toggleseqbtn" class="playpausebtn" onclick="toggleSeq()">⏵︎</button> -->
  <!--                 <div id="seqstats"></div> -->
  <!--             </div> -->
  <!--         </div> -->
  <!--     </div> -->
  <!-- </div> -->
